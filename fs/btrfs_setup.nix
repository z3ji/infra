{
  pkgs,
  fs,
  host,
  util,
  ...
}: let
  # Function to concatenate strings with a separator
  join = pkgs.lib.strings.concatStringsSep;
in
  pkgs.writeShellApplication {
    name = "btrfs_setup_${host}";

    # Runtime inputs required by the application
    runtimeInputs = with pkgs; [btrfs-progs];

    # Shell script text
    text = ''
      # Auto-generated by btrfs_setup.nix. DO NOT EDIT.

      # Prompt for confirmation before applying the configuration
      read -p "This will apply the config to ${join ", " (util.mapKeys fs.order (dev: fs.devices.${dev}.path))}. Are you sure? [y/N] " -r
      if [[ ! $REPLY =~ ^[Yy]$ ]]; then exit 1; fi

      # Enable verbose mode
      set -x

      # Root directory for mounting
      ROOT=/mnt

      # Loop over devices and perform setup
      ${join "" (util.mapAttrsToList fs.devices (devName: devProps: let
        dev = devProps.path;
        subvols = devProps.subvols or [];
        mounts = devProps.mounts or [];
      in ''
        : "Setting up ${devName} (${dev})..."

        # Mounting the device
        MNT="/setup/${devName}/"
        mkdir -p "$MNT"
        mount "${dev}" "$MNT"

        # Check for existing subvolumes
        : "Checking for existing subvolumes..."
        if compgen -G "$MNT/@*"; then
            : "Some subvolumes already exist on ${devName} (${dev})."
            : "Do you want to proceed? Existing subvolumes will be re-used."
            : "This might cause trouble if they're not compatible with the new config."
            read -p "[y/N] " -r
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then umount "$MNT"; exit 1; fi
        fi

        # Create subvolumes
        : "Creating subvolumes..."
        ${join "" (util.mapAttrsToList subvols (subName: subProps: ''
          : "Creating subvolume ${subName} at ${subProps.mount} if it doesn't exist"
          if [ ! -d "$MNT/${subName}" ]; then
              btrfs subvolume create "$MNT/${subName}";
          else
              : "Subvolume ${subName} already exists! Re-using it, if something fails here fix it manually."
          fi
          ${join "" (util.mapAttrsToList (subProps.additional_mounts or []) (mount: ''
            : "Mounting ${subName} at ${mount}"
            mkdir -p "$ROOT${mount}"
            mount -o "subvol=${subName},noatime,compress=${subProps.compress}" "${dev}" "$ROOT${mount}"
          ''))}
        ''))}

        # Unmount the temporary mount point
        umount "$MNT"

        # Mount additional paths
        : "Mounting additional paths..."
        ${join "" (util.map (mount: ''
            mkdir -p "$ROOT${mount}"
            mount "${dev}" "$ROOT${mount}"
          '')
          mounts)}
      ''))}
    '';
  }
